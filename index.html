<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Terminal CIPNET</title>
  <style>
    /* Reset básico e fundo */
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { width:100%; height:100%; background:#000; color:#0f0; font-family:monospace; overflow:hidden; }
    #screen { position:relative; width:100%; height:100%; padding:20px; white-space:pre-wrap; }

    /* Efeito scanline */
    #screen::before {
      content:""; pointer-events:none;
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:
        repeating-linear-gradient(rgba(0,0,0,0.1) 0, rgba(0,0,0,0.1) 1px,
                                 transparent 1px, transparent 3px);
      mix-blend-mode:multiply;
      animation:glitch 0.3s infinite alternate;
    }
    @keyframes glitch {
      0% { transform:translate(0,0); }
      100% { transform:translate(1px,1px); }
    }

    /* Input de texto */
    .input { background:transparent; border:none; border-bottom:1px solid #0f0; color:#0f0; outline:none; }

    /* Canvas do labirinto */
    #mazeCanvas { display:block; margin:20px auto; background:#000; }

    /* Grid de digitação */
    #typeGrid { margin-top:20px; }
    #typeGrid input { width:100%; background:transparent; border:none; color:#0f0; outline:none; font-family:monospace; }

    /* Timer */
    #timer { position:absolute; bottom:20px; right:20px; font-size:1.2em; }
  </style>
</head>
<body>
  <div id="screen"></div>
  <script>
  document.addEventListener('DOMContentLoaded', ()=>{

    const screen = document.getElementById('screen');
    let state = 0;            // controla fluxo de telas
    let menuIdx = 0;          // índice de seleção de menu

    /* === 1) Animação inicial de “run CIPNET” === */
    const initialText = 'run CIPNET';
    let idxChar = 0;
    function typeInitial() {
      if (idxChar < initialText.length) {
        screen.textContent += initialText[idxChar++];
        setTimeout(typeInitial, 100);
      } else {
        setTimeout(showRunning, 300);
      }
    }
    typeInitial();

    /* === 2) “Running…”, ASCII CIPNET e prompt de senha === */
    function showRunning(){
      screen.textContent = 'Running CIPNET.EXE...';
      setTimeout(()=>{
        // ASCII art CIPNET (pode editar livremente aqui)
        screen.textContent = '\n' +
`   ____ ____  _____ _   _ 
  / ___/ ___|| ____| \\ | |
 | |   \\___ \\|  _| |  \\| |
 | |___ ___) | |___| |\\  |
  \\____|____/|_____|_| \\_|
`;
        setTimeout(showPassword, 800);
      }, 800);
    }

    function showPassword(){
      state = 1;
      screen.textContent = '\nPOR FAVOR, INSIRA SUA SENHA:\n';
      const inp = document.createElement('input');
      inp.type='password'; inp.maxLength=5; inp.className='input';
      screen.appendChild(inp);
      inp.focus();
      inp.addEventListener('keydown', e=>{
        if (e.key==='Enter') checkPassword(inp.value);
      });
    }

    /* === 3) Validação de senha e painel admin === */
    function checkPassword(val){
      if (val==='1973') showMenu();
      else if (val==='55555') showAdmin();
      else {
        screen.textContent = 'SENHA INVÁLIDA.\nTENTE NOVAMENTE.';
        setTimeout(showPassword, 800);
      }
    }

    function showAdmin(){
      screen.textContent = '*** PAINEL ADMINISTRADOR ***\n(Funções avançadas em breve)';
    }

    /* === 4) Menu principal com setas + Enter === */
    const menuItems = ['DIREÇÃO DE SISTEMAS','DESENVOLVIMENTO TECNOLÓGICO','ARQUIVOS'];
    function showMenu(){
      state = 2; menuIdx = 0; renderMenu();
      document.addEventListener('keydown', menuNav);
    }
    function renderMenu(){
      screen.textContent = 'BEM VINDO!\nESCOLHA A FUNÇÃO NECESSÁRIA:\n\n';
      menuItems.forEach((it,i)=>{
        screen.textContent += (i===menuIdx?'▶ ':'  ') + '>' + it + '\n';
      });
    }
    function menuNav(e){
      if (state!==2) return;
      if (e.key==='ArrowUp')   menuIdx=(menuIdx+menuItems.length-1)%menuItems.length, renderMenu();
      if (e.key==='ArrowDown') menuIdx=(menuIdx+1)%menuItems.length, renderMenu();
      if (e.key==='Enter'){
        document.removeEventListener('keydown', menuNav);
        if (menuIdx===0) showDesktop3();
        if (menuIdx===1) showPuzzleFlow();
        if (menuIdx===2) showFiles();
      }
    }

    /* === 5) “Desktop 3”: Seleção de trajetória === */
    function showDesktop3(){
      state = 3; let idx = 0;
      const opts = ['CLONAR CARTÃO DE ACESSO','ACESSAR SISTEMAS','OUTROS'];
      function draw(){
        screen.textContent = 'CARREGANDO SISTEMA...\n\nSELECIONE TRAJETÓRIA:\n\n';
        opts.forEach((o,i)=>{
          screen.textContent += (i===idx?'▶ ':'  ') + '>' + o + '\n';
        });
      }
      draw();
      document.addEventListener('keydown', nav);
      function nav(e){
        if (e.key==='ArrowUp')   idx=(idx+opts.length-1)%opts.length, draw();
        if (e.key==='ArrowDown') idx=(idx+1)%opts.length,          draw();
        if (e.key==='Enter'){
          document.removeEventListener('keydown', nav);
          showPuzzleFlow();
        }
      }
    }

    /* === 6) Puzzle Flow: Labirinto + digitação === */
    function showPuzzleFlow(){
      showMaze(15,15);  // gera um labirinto 15×15
    }

    /* 6.1) Geração e render do labirinto (DFS) */
    function showMaze(cols, rows){
      state = 4;
      screen.innerHTML = '';
      const canvas = document.createElement('canvas');
      const size = Math.min(window.innerWidth, window.innerHeight) - 100;
      canvas.id = 'mazeCanvas';
      canvas.width = canvas.height = size;
      screen.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      const cellW = size/cols, cellH = size/rows;

      // Matriz de células
      const grid = [], stack = [];
      for(let x=0;x<cols;x++){
        grid[x] = [];
        for(let y=0;y<rows;y++){
          grid[x][y] = { x, y, vis:false, walls:[true,true,true,true] };
        }
      }
      let current = grid[0][0];
      current.vis = true; stack.push(current);

      // Desenha paredes e start/finish
      function draw(){
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,size,size);
        // paredes
        ctx.fillStyle = '#0f0';
        for(let x=0;x<cols;x++){
          for(let y=0;y<rows;y++){
            const cell = grid[x][y], X = x*cellW, Y = y*cellH;
            if (cell.walls[0]) ctx.fillRect(X,Y,cellW,2);
            if (cell.walls[1]) ctx.fillRect(X+cellW-2,Y,2,cellH);
            if (cell.walls[2]) ctx.fillRect(X,Y+cellH-2,cellW,2);
            if (cell.walls[3]) ctx.fillRect(X,Y,2,cellH);
          }
        }
        // ponto de partida (listras diagonais)
        ctx.fillStyle = ctx.createPattern(createStriped(6,true),'repeat');
        ctx.fillRect(0,0,cellW,cellH);
        // ponto de chegada (listras horizontais)
        ctx.fillStyle = ctx.createPattern(createStriped(6,false),'repeat');
        ctx.fillRect((cols-1)*cellW,(rows-1)*cellH,cellW,cellH);
      }

      // Cria canvas auxiliar com padrão de listras
      function createStriped(sizeStripe, diagonal){
        const p = document.createElement('canvas');
        p.width = p.height = sizeStripe;
        const c = p.getContext('2d');
        c.fillStyle = '#0f0';
        if (diagonal) {
          c.fillRect(0, sizeStripe-2, sizeStripe, 2);
          c.translate(0,sizeStripe); c.rotate(-Math.PI/4);
          c.fillRect(0,0, sizeStripe*2,2);
        } else {
          c.fillRect(0,0,sizeStripe,2);
          c.fillRect(0,4,sizeStripe,2);
        }
        return p;
      }

      // Gerador procedural (depth‑first)
      function carve(){
        if (stack.length){
          const cur = stack.pop(), {x,y} = cur;
          const neighbors = [];
          [[0,-1,0],[1,0,1],[0,1,2],[-1,0,3]].forEach(([dx,dy,dir])=>{
            const nx=x+dx, ny=y+dy;
            if (nx>=0&&nx<cols&&ny>=0&&ny<rows && !grid[nx][ny].vis) {
              neighbors.push({cell:grid[nx][ny], dir});
            }
          });
          if (neighbors.length){
            stack.push(cur);
            const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
            cur.walls[pick.dir] = false;
            pick.cell.walls[(pick.dir+2)%4] = false;
            pick.cell.vis = true;
            stack.push(pick.cell);
          }
          draw();
          requestAnimationFrame(carve);
        } else {
          initPlayer();
          setTimeout(showTypePuzzle, 300);
        }
      }

      carve();

      /* 6.2) Controle do jogador no labirinto */
      let px=0, py=0;
      function initPlayer(){
        // posição inicial
        px = 0; py = 0;
        drawPlayer();
        document.addEventListener('keydown', movePlayer);
      }
      function drawPlayer(){
        draw(); // redesenha tudo
        ctx.fillStyle = '#0f0';
        ctx.fillRect(px*cellW+2, py*cellH+2, cellW-4, cellH-4);
      }
      function movePlayer(e){
        const dirMap = {
          ArrowUp:    [ 0,-1],
          ArrowDown:  [ 0, 1],
          ArrowLeft:  [-1, 0],
          ArrowRight: [ 1, 0]
        };
        if (!dirMap[e.key]) return;
        const [dx,dy] = dirMap[e.key];
        const cell = grid[px][py];
        // verifica parede
        const dirIdx = dx===1?1: dx===-1?3: dy===1?2:0;
        if (!cell.walls[dirIdx]) {
          px += dx; py += dy;
          drawPlayer();
          // vitória?
          if (px===cols-1 && py===rows-1) {
            document.removeEventListener('keydown',movePlayer);
          }
        }
      }
    }

    /* === 7) Puzzle de digitação de sequência === */
    function showTypePuzzle(){
      state = 5;
      screen.innerHTML = 'PUZZLE 2: digite a sequência abaixo e pressione Enter:\n\n';
      // gera sequência aleatória
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
      let seq = '';
      for(let i=0;i<12;i++) seq += chars.charAt(Math.floor(Math.random()*chars.length));
      screen.textContent += seq + '\n\n';
      // input
      const inp = document.createElement('input');
      inp.className = 'input';
      screen.appendChild(inp);
      inp.focus();
      inp.addEventListener('keydown', e=>{
        if (e.key==='Enter') {
          if (inp.value === seq) showFinal();
          else {
            screen.textContent = 'SEQUÊNCIA INCORRETA.\nTENTE NOVAMENTE.\n\n' + seq + '\n\n';
            screen.appendChild(inp);
            inp.value = '';
            inp.focus();
          }
        }
      });
    }

    /* === 8) Tela final e timer de 90s === */
    function showFinal(){
      screen.innerHTML = 'PUZZLES CONCLUÍDOS COM SUCESSO.\nConteúdo exibido aqui.\n\nPressione qualquer tecla para reiniciar.';
      // exibe timer regressivo de 90s no labirinto
      const timer = document.createElement('div');
      timer.id = 'timer';
      document.body.appendChild(timer);
      let time=90;
      const iv = setInterval(()=>{
        timer.textContent = `Tempo restante: ${time--}s`;
        if (time<0) clearInterval(iv);
      },1000);
      document.addEventListener('keydown', ()=>location.reload());
    }

    /* === 9) Desktop 5: Listagem de Arquivos (stub) === */
    function showFiles(){
      screen.textContent = 'CARREGANDO SISTEMA...\n\n>ARQUIVOS TÉCNICOS\n>RELATÓRIOS INTERNOS\n>PROTOCOLOS DE CAMPO\n\n(stub)';
    }

  }); // end DOMContentLoaded
  </script>
</body>
</html>
er